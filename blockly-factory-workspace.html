<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="./blockly.html">
<link rel="import" href="./blockly-workspace.html">
<link rel="stylesheet" type="text/css" href="../flexb0x/flexb0x.css">
<script src="./js/blocks.js"></script>

<dom-module id="blockly-factory-workspace">
	<template>
		<style>
			:host {
				position: relative;
			}
		</style>

		<blockly-workspace id="workspace" class="fl-full" resizable grid snap on-change="onEditorChange_">
			<xml class="toolbox">
				<category name="Input" colour="210">
					<block type="input_value"></block>
					<block type="input_statement"></block>
					<block type="input_dummy"></block>
				</category>
				<category name="Field" colour="160">
					<block type="field_static"></block>
					<block type="field_input"></block>
					<block type="field_angle"></block>
					<block type="field_dropdown"></block>
					<block type="field_checkbox"></block>
					<block type="field_colour"></block>
					<!--
					Date picker commented out since it increases footprint by 60%.
					Add it only if you need it.	See also goog.require in blockly.js.
					<block type="field_date"></block>
					-->
					<block type="field_variable"></block>
					<block type="field_image"></block>
				</category>
				<category name="Type" colour="230">
					<block type="type_group"></block>
					<block type="type_null"></block>
					<block type="type_boolean"></block>
					<block type="type_number"></block>
					<block type="type_string"></block>
					<block type="type_list"></block>
					<block type="type_other"></block>
				</category>
				<category name="Colour" id="colourCategory" colour="0">
					<block type="colour_hue"><mutation colour="20"></mutation><field name="HUE">20</field></block>
					<block type="colour_hue"><mutation colour="65"></mutation><field name="HUE">65</field></block>
					<block type="colour_hue"><mutation colour="120"></mutation><field name="HUE">120</field></block>
					<block type="colour_hue"><mutation colour="160"></mutation><field name="HUE">160</field></block>
					<block type="colour_hue"><mutation colour="210"></mutation><field name="HUE">210</field></block>
					<block type="colour_hue"><mutation colour="230"></mutation><field name="HUE">230</field></block>
					<block type="colour_hue"><mutation colour="260"></mutation><field name="HUE">260</field></block>
					<block type="colour_hue"><mutation colour="290"></mutation><field name="HUE">290</field></block>
					<block type="colour_hue"><mutation colour="330"></mutation><field name="HUE">330</field></block>
				</category>
				<category name="Value" colour="30">
					<block type="text"></block>
				</category>
			</xml>
			<xml class="blocks">
				<block type="factory_base" deletable="false" x="10" y="10"></block>
			</xml>
		</blockly-workspace>
	</template>

	<script>
		'use strict';

		Polymer({
			is: 'blockly-factory-workspace',

			properties: {
				code: {
					type: String,
					notify: true
				}
			},

			// get the generated block definition code
			get code_() {
				let rootBlock = this.rootBlock_;
				if (!rootBlock) {
					return '';
				}
				let blockType = rootBlock.getFieldValue('NAME').trim().toLowerCase();
				if (!blockType) {
					blockType = 'unnamed';
				}
				blockType = blockType.replace(/\W/g, '_').replace(/^(\d)/, '_\\1');
				return this.formatJavaScript_(blockType, rootBlock);
			},

			onEditorChange_() {
				this.code = this.code_;
				this.fire('change');
			},

			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			// PRIVATE METHODS TO GENERATE THE BLOCK DEFINITION CODE //////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////////////////////////////////
			///////////////////////////////////////////////////////////////////////////////////////////////////////////

			/**
			 * Return the uneditable container block that everything else attaches to.
			 * @return {Blockly.Block}
			 */
			get rootBlock_() {
				let blocks = this.$.workspace.workspace.getTopBlocks(false);
				for(let block of blocks) {
					if(block.type === 'factory_base') {
						return block;
					}
				}
				return null;
			},

			/**
			 * Update the language code as JavaScript.
			 * @param {string} blockType Name of block.
			 * @param {!Blockly.Block} rootBlock Factory_base block.
			 * @return {string} Generanted language code.
			 * @private
			 */
			formatJavaScript_(blockType, rootBlock) {
				var code = [];
				code.push("Blockly.Blocks['" + blockType + "'] = {");
				code.push("  init: function() {");
				// Generate inputs.
				var TYPES = {
					'input_value': 'appendValueInput',
					'input_statement': 'appendStatementInput',
					'input_dummy': 'appendDummyInput'
				};
				var contentsBlock = rootBlock.getInputTargetBlock('INPUTS');
				while (contentsBlock) {
					if (!contentsBlock.disabled && !contentsBlock.getInheritedDisabled()) {
						var name = '';
						// Dummy inputs don't have names.  Other inputs do.
						if (contentsBlock.type != 'input_dummy') {
							name = this.escapeString_(contentsBlock.getFieldValue('INPUTNAME'));
						}
						code.push('    this.' + TYPES[contentsBlock.type] + '(' + name + ')');
						var check = this.getOptTypesFrom_(contentsBlock, 'TYPE');
						if (check) {
							code.push('        .setCheck(' + check + ')');
						}
						var align = contentsBlock.getFieldValue('ALIGN');
						if (align != 'LEFT') {
							code.push('        .setAlign(Blockly.ALIGN_' + align + ')');
						}
						var fields = this.getFieldsJs_(contentsBlock.getInputTargetBlock('FIELDS'));
						for (var i = 0; i < fields.length; i++) {
							code.push('        .appendField(' + fields[i] + ')');
						}
						// Add semicolon to last line to finish the statement.
						code[code.length - 1] += ';';
					}
					contentsBlock = contentsBlock.nextConnection &&
						contentsBlock.nextConnection.targetBlock();
				}
				// Generate inline/external switch.
				if (rootBlock.getFieldValue('INLINE') == 'EXT') {
					code.push('    this.setInputsInline(false);');
				} else if (rootBlock.getFieldValue('INLINE') == 'INT') {
					code.push('    this.setInputsInline(true);');
				}
				// Generate output, or next/previous connections.
				switch (rootBlock.getFieldValue('CONNECTIONS')) {
					case 'LEFT':
						code.push(this.connectionLineJs_('setOutput', 'OUTPUTTYPE'));
						break;
					case 'BOTH':
						code.push(this.connectionLineJs_('setPreviousStatement', 'TOPTYPE'));
						code.push(this.connectionLineJs_('setNextStatement', 'BOTTOMTYPE'));
						break;
					case 'TOP':
						code.push(this.connectionLineJs_('setPreviousStatement', 'TOPTYPE'));
						break;
					case 'BOTTOM':
						code.push(this.connectionLineJs_('setNextStatement', 'BOTTOMTYPE'));
						break;
				}
				// Generate colour.
				var colourBlock = rootBlock.getInputTargetBlock('COLOUR');
				if (colourBlock && !colourBlock.disabled) {
					var hue = parseInt(colourBlock.getFieldValue('HUE'), 10);
					code.push(`    this.setColour(${hue});`);
				}
				// Generate Tooltip
				var tooltipBlock = rootBlock.getInputTargetBlock('TOOLTIP');
				if (tooltipBlock && !tooltipBlock.disabled) {
					var tooltip = this.escapeString_(tooltipBlock.getFieldValue('TEXT'));
					code.push(`    this.setTooltip(${tooltip});`);
				}
				// Generate HelpUrl
				var helpBlock = rootBlock.getInputTargetBlock('HELP');
				if (helpBlock && !helpBlock.disabled) {
					var url = this.escapeString_(helpBlock.getFieldValue('TEXT'));
					code.push(`    this.setHelpUrl(${url});`);
				}
				
				code.push('  }');
				code.push('};\n');

				code.push(`//Blockly.JavaScript['${blockType}'] = function(block) { ... }`);

				return code.join('\n');
			},

			/**
			 * Returns field strings and any config.
			 * @param {!Blockly.Block} block Input block.
			 * @return {!Array.<string>} Field strings.
			 * @private
			 */
			getFieldsJs_(block) {
				var fields = [];
				while (block) {
					if (!block.disabled && !block.getInheritedDisabled()) {
						switch (block.type) {
							case 'field_static':
								// Result: 'hello'
								fields.push(this.escapeString_(block.getFieldValue('TEXT')));
								break;
							case 'field_input':
								// Result: new Blockly.FieldTextInput('Hello'), 'GREET'
								fields.push('new Blockly.FieldTextInput(' +
									this.escapeString_(block.getFieldValue('TEXT')) + '), ' +
									this.escapeString_(block.getFieldValue('FIELDNAME')));
								break;
							case 'field_angle':
								// Result: new Blockly.FieldAngle(90), 'ANGLE'
								fields.push('new Blockly.FieldAngle(' +
									parseFloat(block.getFieldValue('ANGLE')) + '), ' +
									this.escapeString_(block.getFieldValue('FIELDNAME')));
								break;
							case 'field_checkbox':
								// Result: new Blockly.FieldCheckbox('TRUE'), 'CHECK'
								fields.push('new Blockly.FieldCheckbox(' +
									this.escapeString_(block.getFieldValue('CHECKED')) + '), ' +
									this.escapeString_(block.getFieldValue('FIELDNAME')));
								break;
							case 'field_colour':
								// Result: new Blockly.FieldColour('#ff0000'), 'COLOUR'
								fields.push('new Blockly.FieldColour(' +
									this.escapeString_(block.getFieldValue('COLOUR')) + '), ' +
									this.escapeString_(block.getFieldValue('FIELDNAME')));
								break;
							case 'field_date':
								// Result: new Blockly.FieldDate('2015-02-04'), 'DATE'
								fields.push('new Blockly.FieldDate(' +
									this.escapeString_(block.getFieldValue('DATE')) + '), ' +
									this.escapeString_(block.getFieldValue('FIELDNAME')));
								break;
							case 'field_variable':
								// Result: new Blockly.FieldVariable('item'), 'VAR'
								var varname = this.escapeString_(block.getFieldValue('TEXT') || null);
								fields.push('new Blockly.FieldVariable(' + varname + '), ' +
									this.escapeString_(block.getFieldValue('FIELDNAME')));
								break;
							case 'field_dropdown':
								// Result:
								// new Blockly.FieldDropdown([['yes', '1'], ['no', '0']]), 'TOGGLE'
								var options = [];
								for (var i = 0; i < block.optionCount_; i++) {
									options[i] = '[' + this.escapeString_(block.getFieldValue('USER' + i)) +
										', ' + this.escapeString_(block.getFieldValue('CPU' + i)) + ']';
								}
								if (options.length) {
									fields.push('new Blockly.FieldDropdown([' +
										options.join(', ') + ']), ' +
										this.escapeString_(block.getFieldValue('FIELDNAME')));
								}
								break;
							case 'field_image':
								// Result: new Blockly.FieldImage('http://...', 80, 60)
								var src = this.escapeString_(block.getFieldValue('SRC'));
								var width = Number(block.getFieldValue('WIDTH'));
								var height = Number(block.getFieldValue('HEIGHT'));
								var alt = this.escapeString_(block.getFieldValue('ALT'));
								fields.push('new Blockly.FieldImage(' +
									src + ', ' + width + ', ' + height + ', ' + alt + ')');
								break;
						}
					}
					block = block.nextConnection && block.nextConnection.targetBlock();
				}
				return fields;
			},

			/**
			 * Fetch the type(s) defined in the given input.
			 * Format as a string for appending to the generated code.
			 * @param {!Blockly.Block} block Block with input.
			 * @param {string} name Name of the input.
			 * @return {?string} String defining the types.
			 */
			getOptTypesFrom_(block, name) {
				var types = this.getTypesFrom_(block, name);
				if (types.length == 0) {
					return undefined;
				} else if (types.indexOf('null') != -1) {
					return 'null';
				} else if (types.length == 1) {
					return types[0];
				} else {
					return '[' + types.join(', ') + ']';
				}
			},

			/**
			 * Fetch the type(s) defined in the given input.
			 * @param {!Blockly.Block} block Block with input.
			 * @param {string} name Name of the input.
			 * @return {!Array.<string>} List of types.
			 * @private
			 */
			getTypesFrom_(block, name) {
				var typeBlock = block.getInputTargetBlock(name);
				var types;
				if (!typeBlock || typeBlock.disabled) {
					types = [];
				} else if (typeBlock.type == 'type_other') {
					types = [this.escapeString_(typeBlock.getFieldValue('TYPE'))];
				} else if (typeBlock.type == 'type_group') {
					types = [];
					for (var n = 0; n < typeBlock.typeCount_; n++) {
						types = types.concat(this.getTypesFrom_(typeBlock, 'TYPE' + n));
					}
					// Remove duplicates.
					var hash = Object.create(null);
					for (var n = types.length - 1; n >= 0; n--) {
						if (hash[types[n]]) {
							types.splice(n, 1);
						}
						hash[types[n]] = true;
					}
				} else {
					types = [this.escapeString_(typeBlock.valueType)];
				}
				return types;
			},

			/**
			 * Escape a string.
			 * @param {string} string String to escape.
			 * @return {string} Escaped string surrouned by quotes.
			 */
			escapeString_(string) {
				return JSON.stringify(string);
			},

			/**
			 * Create JS code required to create a top, bottom, or value connection.
			 * @param {string} functionName JavaScript function name.
			 * @param {string} typeName Name of type input.
			 * @return {string} Line of JavaScript code to create connection.
			 * @private
			 */
			connectionLineJs_(functionName, typeName) {
				var type = this.getOptTypesFrom_(this.rootBlock_, typeName);
				if (type) {
					type = ', ' + type;
				} else {
					type = '';
				}
				return '    this.' + functionName + '(true' + type + ');';
			}
		});
	</script>
</dom-module>